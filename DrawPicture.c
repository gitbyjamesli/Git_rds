/**************************************************************

 在LCD19264液晶屏上实现画点、画线、画矩形的功能函数

 建立日期：2012-11-23/文友


 备注：





 版本：V10


*/
// 包含文件------------------------------------------------------------------------------
#include "LCD19264_DriverV20.h"// 19264液晶屏的底层驱动
#include <stdlib.h>
#include <stdint.h>

//宏定义--------------------------------------------------------------------------------
typedef signed short int s16;
typedef unsigned short int u16;

//变量声明------------------------------------------------------------------------------
unsigned char DDRAM[8][192];// 显存 8行，每行有192列
extern unsigned char const FONT6x8[][6];// LCD19264_DriverV20.c中定义的点阵数据-ascii字库


unsigned char const logo_RDS[192*4]=
{
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0x40,0x20,0x10,
0x90,0x88,0xC8,0x4C,0x64,0x24,0x24,0x24,0x24,0x24,0x24,0x24,0x64,0x44,0x40,0x08,0x88,0x50,0x60,0x30,0x30,0x98,0x88,0xC8,0x4C,0x64,0x24,0x24,0x24,0x24,0x24,0x24,
0x24,0x64,0x4C,0x48,0x88,0x98,0x10,0x20,0x40,0xC0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0xF8,0xF8,0xF8,0xF8,0x78,0x78,
0x78,0x78,0xF8,0xF8,0xF0,0xE0,0xE0,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xF0,0xE0,
0xE0,0xC0,0xC0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0xE0,0xF0,0xF0,0xF8,0xF8,0xF8,0xF8,0xF8,0xF0,0xF0,0xF0,0x70,
0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x70,0x0C,0x03,0xE1,0x38,0x1C,0x06,0xE3,
0xF1,0xF8,0xFC,0xFE,0xFE,0xFF,0x7F,0x7F,0x3F,0x3F,0x7F,0x7F,0xFE,0x3E,0x06,0x03,0xF0,0x18,0x04,0xC3,0xE3,0xF9,0xFC,0xFE,0xFE,0xFE,0xFF,0x7F,0x3F,0x3F,0x3F,0x7F,
0x7F,0xFE,0xFE,0xFE,0xFC,0xF8,0xE1,0x02,0x0C,0x38,0x20,0x83,0x06,0x78,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0xFC,0xFF,0xFF,0xFF,0xEF,0xE3,0xE0,0xE0,
0xE0,0xF0,0xF8,0x7F,0x3F,0x3F,0x1F,0x07,0x00,0x00,0x00,0xC0,0xF8,0xFC,0xFC,0x1C,0x00,0x00,0x00,0xC0,0xF8,0xFF,0xFF,0x3F,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x83,
0xFF,0xFF,0xFF,0xFF,0x7E,0x00,0x00,0x00,0x80,0xF8,0xFC,0xFC,0x1C,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x0F,0x1F,0x3F,0x7F,0xF8,0xF0,0xF0,0xE1,0xC1,0xC1,0x00,0x00,
0x00,0x00,0x80,0xF8,0xFC,0x7C,0x1C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x7E,0xFF,0xFF,0xFF,0xFF,0xFF,0xFE,0xE3,
0xC3,0x87,0x1F,0x23,0x43,0x44,0x98,0x90,0x90,0x90,0x90,0x88,0x47,0x60,0x30,0x1F,0x80,0xC0,0xF0,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x3F,0xCC,0x98,0x90,0x90,0x90,0x98,
0xC8,0x47,0x63,0x33,0x0F,0x87,0xE3,0xF9,0xFE,0xFF,0xFF,0xFF,0xFF,0xFE,0x1F,0x00,0x00,0x00,0x00,0x00,0x20,0x38,0x3E,0x3F,0x3F,0x3F,0x1F,0x07,0x01,0x07,0x1F,0x3F,
0xBF,0xBF,0xBE,0xBE,0xB8,0xA0,0x00,0x00,0x00,0xC0,0xF8,0xFF,0xFF,0x07,0x00,0x00,0x00,0x20,0x3C,0x3F,0x3F,0x3F,0x3D,0x3C,0x3C,0x3C,0x3C,0x3C,0x3C,0x3E,0x1F,0x9F,
0x9F,0x8F,0x03,0x03,0x00,0x00,0x00,0xC0,0xFF,0xFF,0x3F,0x00,0x00,0x00,0x00,0x0E,0x1F,0x1E,0x1E,0x1C,0x3C,0x3C,0x3C,0xBF,0x9F,0x1F,0x1F,0x1F,0x0F,0x87,0x80,0x00,
0x80,0xF8,0xFF,0x7F,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x07,0x0F,0x1F,0x1F,0x3F,
0x3F,0x7F,0x7F,0xFE,0xFE,0xFE,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,0xFE,0xFE,0xFE,0x7F,0x3F,0x3F,0x3F,0x1F,0x1F,0x6F,0x77,0x79,0xFC,0xFE,0xFC,0xFC,0xFC,0xFC,0xFC,0xFC,
0xFC,0xFE,0xFE,0x7F,0x7F,0x7F,0x3F,0x1F,0x1F,0x0F,0x07,0x03,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x3F,
0x27,0x24,0x24,0x24,0x24,0x00,0x00,0x00,0x3E,0x3F,0x3F,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1C,0x3F,0x63,0x61,
0x61,0x33,0x3F,0x06,0x00,0x00,0x38,0x3F,0x3F,0x0F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x60,0x7E,0x1F,0x07,0x0C,0x18,0x38,0x7F,0x1B,0x00,0x38,
0x3F,0x3F,0x0F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};


//函数声明-------------------------------------------------------------------------------



void Draw_Clear_DDRAM(void)
{
	unsigned char n,m;
	for(n=0;n<8;n++)
	{
		for(m=0;m<192;m++)
		{
			DDRAM[n][m] = 0;
		}
	}
}
void Draw_UpdateToLCD(void)// 将DDRAM所有点更新至整屏
{
	unsigned char x,y;
	for(x=0;x<192;x++)
	{
		for(y=0;y<8;y++)
		{
			LCD19264_Posbyte(x,y,DDRAM[y][x]);
		}
	}
}
void Draw_Point_DDRAM(u16 x,u16 y,u16 color)// DDRAM中指定坐标设置，1点亮，0点灭
{
	if(x<192 && y<64)
	{
		unsigned char *temp = &DDRAM[y/8][x];
		if(color)
		{
			*temp |= 0x1<<(y%8);	
		}
		else
		{
			*temp &= ~(0x1<<(y%8));	
		}
	}
}

void Draw_Point(u16 x,u16 y,u16 color)
{
	if(x<192 && y<64)
	{
		unsigned char *temp = &DDRAM[y/8][x];
		if(color)
		{
			*temp |= 0x1<<(y%8);	
		}
		else
		{
			*temp &= ~(0x1<<(y%8));	
		}
		LCD19264_Posbyte(x,y/8,*temp);
	}
}

unsigned char Draw_GetPointColor(u16 x,u16 y)// 获取DDRAM中指定坐标的点状态，返回 1点亮，0点灭
{
	unsigned char *temp = &DDRAM[y/8][x];
	if((*temp)&(1<<(y%8)))
	{
		return 1;
	}
	else
	{
		return 0;
	}
}

/*****************************************************************
 画一条横线
*/
void Draw_XLine(u16 x0,u16 y0,u16 x1,u16 color)
{
	u16 temp;
	if(x0 > x1)
	{
		temp = x1;
		x1 = x0;
		x0 = temp;
	}
	for(;x0 <= x1; x0++)
	{
		Draw_Point(x0,y0,color);
	}
}
/*****************************************************************
 画一条竖线
*/
void Draw_YLine(u16 x0,u16 y0,u16 y1,u16 color)
{
	u16 temp;
	if(y0 > y1)
	{
		temp = y1;
		y1 = y0;
		y0 = temp;
	}
	for(;y0 <= y1; y0++)
	{
		Draw_Point(x0,y0,color);
	}
}
/********************************************************** 
 名称：Draw_Rect(u16 xs,u16 ys,u16 xe,u16 ye,u16 color)
 功能：根据坐标画一矩形 
 入口参数:	
		 xs 起点所在行的位置 
		 ys 起点所在列的位置 
		 xe 起点所在行的位置 
		 ye 起点所在列的位置 
		 color 显示颜色(对于黑白色LCD12864，为0时灭，为1时显示) 
 出口参数：无 
**********************************************************/ 
void Draw_Rect(u16 xs,u16 ys,u16 xe,u16 ye,u16 color)
{
	Draw_XLine(xs,ys,xe,color);
	Draw_XLine(xs,ye,xe,color);
	Draw_YLine(xs,ys,ye,color);
	Draw_YLine(xe,ys,ye,color);
}
void Draw_Fill(u16 xs,u16 ys,u16 xe,u16 ye,u16 color)
{
	u16 i;
	for(i=ys;i<ye;i++)
	{
		Draw_XLine(xs,i,xe,color);
	}
	
}
/********************************************************
* 名称：Draw_Line(u16 x0,u16 y0,u16 x1,u16 y1,u16 color)
*      
* 功能：任意两点间的直线。根据硬件特点，实现加速。
*
* 入口参数：x0       直线起点所在行的位置
*			y0       直线起点所在列的位置
*			x1       直线终点所在行的位置
*           y1       直线终点所在列的位置
* 出口参数：无
* 说明：操作失败原因是指定地址超出缓冲区范围
*********************************************************/
void Draw_Line(u16 x0,u16 y0,u16 x1,u16 y1,u16 color)
{
	s16 delta_x,delta_y;
	s16 incx,incy;
	s16 x=0,y=0;
	s16 distance,t;

	delta_x = x1 - x0;
	delta_y = y1 - y0;
	if(delta_x > 0)
	{
		incx = 1;
	}else if(delta_x == 0)
	{
		Draw_YLine(x0,y0,y1,color);//画条竖线再退出
		return;
	}else
	{
		incx = -1;
	}
	if(delta_y > 0)
	{
		incy = 1;
	}else if(delta_y == 0)
	{
		Draw_XLine(x0,y0,x1,color);//画条横线再退出
		return;
	}else
	{
		incy = -1;
	}
	delta_x = abs(delta_x);
	delta_y = abs(delta_y);
	if( delta_x > delta_y )
	{
		distance = delta_x ;
	}
	else
	{
		distance = delta_y ; 
	}
	Draw_Point(x0,y0,color);//发现没用!
	//开始画线
	for(t = 0; t <= distance+1; t++)
	{
		Draw_Point(x0,y0,color);
		x += delta_x;
		y += delta_y;
		if(x > distance)
		{
			x -= distance;
			x0 += incx; 
		}
		if(y > distance)
		{
			y -= distance;
			y0 += incy;
		}
	}
}
/*****************************************
 名称：Draw_Circle (在任意位置画圆)
 说明：使用Bresenham法画1/8个圆，在用对称性画出其他的7/8个圆 
    

    按下图把圆分为8份
        0
      7     1
    6         2
      5     3
        4 
*****************************************/
void Draw_Circle(u16 x0,u16 y0,u16 r,u16 color)
{
	u16 a,b;
	s16 di;

	a = 0;
	b = r;
	di = 3-2*r;             //判断下个点位置的标志
	while(a <= b)
	{
		Draw_Point(x0-b,y0-a,color);             //3           
		Draw_Point(x0+b,y0-a,color);             //0           
		Draw_Point(x0-a,y0+b,color);             //1       
		Draw_Point(x0-b,y0-a,color);             //7           
		Draw_Point(x0-a,y0-b,color);             //2             
		Draw_Point(x0+b,y0+a,color);             //4               
		Draw_Point(x0+a,y0-b,color);             //5
		Draw_Point(x0+a,y0+b,color);             //6 
		Draw_Point(x0-b,y0+a,color);             
		a++;
		//使用Bresenham算法画圆     
		if(di<0)
		{
			di += 4*a+6;
		}
		else
		{
			di += 10 + 4 * (a-b);   
			b--;
		} 
		Draw_Point(x0+a,y0+b,color);
	}
}







// ---------功能分割线---------------------------------------------------

void Draw_Clear(void)
{
	Draw_Clear_DDRAM();
	Draw_UpdateToLCD();// 更新至屏幕
}
void Draw_Ascii6X8(unsigned char x,unsigned char y,char asc)// 画6X8的字符
{
	unsigned char i,n;
	unsigned char byte;

	if(asc > 'z' || asc < ' ')	 asc = 'z'+1;

	asc -= 0x20;
	for(i=0;i<6;i++)// 6列
	{
		byte = FONT6x8[asc][i];
		for(n=0;n<8;n++)// 每列8个点
		{
			if(byte&1)
			{
				Draw_Point(x+i,y+n,1);
			}
			else
			{
				Draw_Point(x+i,y+n,0);
			}
			byte >>= 1;
		}
	}
}
void Draw_Ascii6X8_Downline(unsigned char x,unsigned char y,char asc)// 画6X8的下划线字符
{
	unsigned char i,n;
	unsigned char byte;

	if(asc > 'z' || asc < ' ')	 asc = 'z'+1;

	asc -= 0x20;
	for(i=0;i<6;i++)// 6列
	{
		byte = FONT6x8[asc][i];
		for(n=0;n<7;n++)
		{
			if(byte&1)
			{
				Draw_Point(x+i,y+n,1);
			}
			else
			{
				Draw_Point(x+i,y+n,0);
			}
			byte >>= 1;
		}
		Draw_Point(x+i,y+7,1);// 下划线
	}
}
void Draw_String6X8(unsigned char x,unsigned char y,char *str)// 画6X8的字符串
{
	unsigned char tp=x;

	while(*str)// 如果是串尾就直接退出
	{
		Draw_Ascii6X8(tp,y,*str++);
		tp += 6;
	}
}

void Draw_Picture_logoRDS(void)
{
	unsigned char i,n;
	unsigned char const *data_p=logo_RDS;

	for(i=0;i<4;i++)
	{
		for(n=0;n<192;n++)
		{
			DDRAM[i][n] = *data_p++;
		}
	}
	Draw_UpdateToLCD();// 更新至屏幕
}

void Draw_Lump_fb(uint8_t xs,uint8_t ys,uint8_t xe,uint8_t ye)// 指定块大小的反白
{
	uint8_t len,n;

	if((xs>xe)||(ys>ye))return ;// 超界，不处理

	for(len=xs;len<=xe;len++)// 每行
	{
		for(n=ys;n<=ye;n++)// 每竖8点
		{
			if(Draw_GetPointColor(len,n))// 点颜色  为有效1
			{
				Draw_Point(len,n,0);// 空点
			}
			else
			{
				Draw_Point(len,n,1);// 实点
			}
		}
	}
}

//---------------- END FILE----------------------------
